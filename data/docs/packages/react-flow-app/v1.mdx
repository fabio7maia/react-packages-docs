---
meta:
  revision: 1
  tags: react; flow; app; navigations; events
---

ğŸš€ Biblioteca React.js com o **objetivo de simplificar as navegaÃ§Ãµes** com foco em eventos (aÃ§Ãµes do utilizador) para facilitar as integraÃ§Ãµes.

Principais funcionalidades:

- ğŸ¤³ Baseado em eventos (aÃ§Ãµes do utilizador)
- ğŸ“¦ ModularizaÃ§Ã£o da AplicaÃ§Ã£o
- âš™ï¸ Centralizado na configuraÃ§Ã£o para gestÃ£o das navegaÃ§Ãµes
- ğŸ”ƒ Maior reutilizaÃ§Ã£o
- ğŸ§© IntegraÃ§Ã£o simplificada (ex: envio de dados analÃ­ticos)
- ğŸ” Total controlo das navegaÃ§Ãµes
- ğŸ’¯ Suporte para Typescript
- ğŸ”„ Carregamento parcial (_lazy loading_)
- ğŸ’» Desenvolvimento com _Intellisense_

<br />
<br />

# âš’ï¸ 1. API

## â„¹ï¸ 1.1. useFlow

Hook que permite aceder a um conjunto de mÃ©todos e propriedades para agilizar as navegaÃ§Ãµes.

Para ter acesso a todos os mÃ©todos, nomeadamente ao dispatch, Ã© necessÃ¡rio passar como parÃ¢metro a configuraÃ§Ã£o do ecrÃ£.

Abaixo sÃ£o descritos os respetivos mÃ©todos e propriedades disponibilizadas.

### ğŸ“ 1.1.1. back

Permite navegar para o Ãºltimo ecrÃ£, de acordo com a configuraÃ§Ã£o do fluxo corrente.

Posteriormente serÃ¡ abordado com mais detalhe e exemplos em concreto.

```jsx
const { back } = useFlow(flowManager.screens.screen1);

...

// chamar para voltar para o ecrÃ£ anterior (quando existe)
back();
```

### ğŸ“ 1.1.2. dispatch

Permite indicar a aÃ§Ã£o/evento a despachar (de acordo com a configuraÃ§Ã£o), nomeadamente as aÃ§Ãµes definidas para o respetivo screen passado no parÃ¢metro do useFlow.

```jsx
const { dispatch } = useFlow(flowManager.screens.screen1);

...

dispatch('<action_name>');
```

### ğŸ“ 1.1.3. getCurrentStep

Permite obter o passo atual.

```jsx
const { getCurrentStep } = useFlow(flowManager.screens.screen1);

...

getCurrentStep();
```

### ğŸ“ 1.1.4. getHistory

Permite obter um array de passos que ficaram armazenados no histÃ³rico e na qual Ã© possÃ­vel voltar.

```jsx
const { getHistory } = useFlow(flowManager.screens.screen1);

...

getHistory();
```

### ğŸ“ 1.1.5. getPreviousStep

Permite obter o passo anterior.

```jsx
const { getPreviousStep } = useFlow(flowManager.screens.screen1);

...

getPreviousStep();
```

### ğŸ“ 1.1.6. hasPreviousStep

Permite verificar se existe passo anterior, retornando true em caso de existir e false nos restantes casos.

```jsx
const { hasPreviousStep } = useFlow(flowManager.screens.screen1);

...

hasPreviousStep();
```

### ğŸ“ 1.1.7. refresh

Permite forÃ§ar a atualizaÃ§Ã£o do passo/ecrÃ£ que estÃ¡ a ser visualizado.

```jsx
const { refresh } = useFlow(flowManager.screens.screen1);

...

refresh();
```

## â„¹ï¸ 1.2. useFlowManager

Hook que tem como objetivo disponibilizar a interaÃ§Ã£o com os fluxos.

### ğŸ“ 1.2.1 start

Permite inicializar um fluxo.

```jsx
const { start } = useFlowManager();

...

start(flows.flow1.start());
```

## â„¹ï¸ 1.3. FlowManager

Permite criar a instÃ¢ncia do flowManager a usar na AplicaÃ§Ã£o (deve ser usada sempre esta instÃ¢ncia para aceder aos ecrÃ£s).

### ğŸ“ 1.3.1. flow

MÃ©todo que permite a criaÃ§Ã£o de fluxos, com a respetiva indicaÃ§Ã£o dos passos que compÃµem o fluxo.

## â„¹ï¸ 1.4. FlowProvider

Provider que permite agilizar todas as navegaÃ§Ãµes, necessitando que seja passada uma instÃ¢ncia do flow manager.

<br />
<br />

# ğŸ§‘ğŸ¼â€ğŸ’» 2. Exemplos

De seguida sÃ£o elencados os passos necessÃ¡rios para o correto funcionamento da biblioteca.

## 2.1. ConfiguraÃ§Ã£o dos ecrÃ£s

NecessÃ¡rio definir as 3 propriedades seguintes:

- **name**: nome do ecrÃ£
- **actions**: array de aÃ§Ãµes que o ecrÃ£ disponibiliza, aÃ§Ãµes estas que ficaram disponÃ­veis no respetivo ecrÃ£ para fazer o respetivo trigger da navegaÃ§Ã£o
- **loader**: funÃ§Ã£o que irÃ¡ permitir carregar o respetivo ecrÃ£ (Ã© recomendado o uso de _lazy loading_)

```jsx
// file: screens/index.tsx
import React from 'react';
import { FlowManager } from 'react-flow-app';

const screens = {
	screen1: {
		name: 'screen1',
		actions: ['next', 'skip'],
		loader: () => React.lazy(() => import('./screen1/screen1')),
	},
	screen2: {
		name: 'screen2',
		actions: ['confirm'],
		loader: () => React.lazy(() => import('./screen2/screen2')),
	},
} as const;

export const flowManager = new FlowManager(screens);
```

## 2.2. EcrÃ£s

```jsx
// file: screens/screen1/screen1.tsx
import React from "react";
import { useFlow } from "react-flow-app";
import { flowManager } from "..";

const Screen1: React.FC = () => {
  const { dispatch } = useFlow(flowManager.screens.screen1);

  return <>
    <h1>Screen 1 example</>
    <button onClick={() => {
      dispatch('next');
    }}>Next</button>
    <button onClick={() => {
      dispatch('skip');
    }}>Skip</button>
  </>
};

export default Screen1;
```

```jsx
// file: screens/screen2/screen2.tsx
import React from "react";
import { useFlow } from "react-flow-app";
import { flowManager } from "..";

const Screen2: React.FC = () => {
  const { dispatch } = useFlow(flowManager.screens.screen2);

  return <>
    <h1>Screen 2 example</>
    <button onClick={() => {
      dispatch('confirm');
    }}>Confirm</button>
  </>
};

export default Screen2;
```

## 2.3. Fluxos

```jsx
// file: flows/flow1.tsx
import { flowManager } from "@screens";

export const flow1 = flowManager
  .flow({ name: "flow1", baseUrl: "flow1" })
  .steps({
    screen1: {
      initialStep: true,
    },
    screen2: {},
  });

hub.step("screen1")({
  next: "screen2",
  skip: () => {
    // executar qualquer js que seja pretendido
  },
});

hub.step("screen2")({
  confirm: "screen1",
});

// integraÃ§Ã£o com terceiros, exemplo: Google Tag Manager, Firebase, etc

// ver ecrÃ£
hub.listen({
  callback: ({ currentStepName }): void => {
    // enviar dados
  },
  type: "mount",
});

// enviar evento
hub.listen({
  callback: ({ currentStepName, dispatch }): void => {
    if (dispatch) {
      const { actionName, payload } = dispatch;

      // enviar dados
    }
  },
  type: "dispatch",
});
```

```jsx
// file: flows/flow2.tsx
import { flowManager } from "@screens";
import { flow1 } from "./flow1";

export const flow2 = flowManager
  .flow({ name: "flow2", baseUrl: "flow2" })
  .steps({
    screen1: {},
    screen2: {
      initialStep: true,
      clearHistory: true,
    },
  });

hub.step("screen1")({
  next: "screen2",
  skip: () => {
    return flow1.navigateTo();
  },
});

hub.step("screen2")({
  confirm: () => {
    return flow1.navigateTo();
  },
});

// integraÃ§Ã£o com terceiros, exemplo: Google Tag Manager, Firebase, etc

// ver ecrÃ£
hub.listen({
  callback: ({ currentStepName }): void => {
    // enviar dados
  },
  type: "mount",
});

// enviar evento
hub.listen({
  callback: ({ currentStepName, dispatch }): void => {
    if (dispatch) {
      const { actionName, payload } = dispatch;

      // enviar dados
    }
  },
  type: "dispatch",
});
```

## 2.4. App

```jsx
// src/index.tsx
import { FlowProvider } from 'react-flow-app';
import { flowManager } from '@screens';

...

<FlowProvider fm={flowManager}>
  <App />
</FlowProvider>

...
```

```jsx
// src/app.tsx
import { useFlowManager } from 'react-flow-app';
import { flow1 } from '@flows';

...
const { start } = useFlowManager();


React.useEffect(() => {
  start(flow1.start());
}, []);

...
```

<br />
<br />

# ğŸ”¥ 3. Trabalho Futuro

- dev tools
